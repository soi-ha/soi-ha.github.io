---
layout: post
categories:
  - TIL
title: "TypeScript: TypeScript Compiler Ep.2 compileOptions"
tags:
  - TIL
  - TS
---
## __compileOptions - typeRoots, types__
---

```json
"typeRoots": {
	"description": "Specify multiple folders that act like `./node_modules/@types`.",
	"type": "array",
	"uniqueItems": true,
	"items": {
		"type": "string"
	},
	"markdownDescription": "Specify multiple folders that act like `./node_modules/@types`."
}
"types": {
	"description": "Specify type package names to be included without being referenced in a source file.",
	"type": "array",
	"uniqueItems": true,
	"items": {
		"type": "string"
	},
	"markdownDescription": "Specify type package names to be included without being referenced in a source file."
}
```

**@types**
- TypeScript 2.0부터 사용 가능해진 내장 type definition 시스템이다.  
이전에는 내장이 아닌 서드파티 type definition이었다. 이제는 내장으로 통합.
- 아무 설정을 하지 않으면
    - node_modules/@types 라는 모든 경로를 찾아서 사용한다.
- typeRoots를 사용하면
    - 배열 안에 들어있는 경로들 아래에서만 가져온다.
    나는 node_modules 안의 @types 도 쓰겠지만 내 프로젝트 안의 @types도 쓸거라면 typeRoots를 지정해 주면 편하게 사용할 수 있다.
- types를 사용하면
    - 배열 안의 모듈 혹은 ./node_modules/@types/ 안의 모듈 이름에서 찾아온다.
    - [ ] 빈 배열을 넣는다는 건 이 시스템을 이용하지 않겠다는 것이다.
- typeRoots 와 types를 같이 사용하지 않는다.

## __compileOptions - target 과 lib__
---

```json
"target": {
	"description": "Set the JavaScript language version for emitted JavaScript and include compatible library declarations.",
	"type": "string",
	"default": "ES3",
	"anyOf": [
		{
			"enum": [
				"ES3",
				"ES5",
				"ES6",
				"ES2015",
				"ES2016",
				"ES2017",
				"ES2018",
				"ES2019",
				"ES2020",
				"ES2021",
				"ES2022",
				"ESNext"
			]
		},
		{
			"pattern": "^([Ee][Ss]([356]|(20(1[56789]|2[012]))|[Nn][Ee][Xx][Tt]))$"
		}
	],
	"markdownDescription": "Set the JavaScript language version for emitted JavaScript and include compatible library declarations."
}

"lib": {
	"description": "Specify a set of bundled library declaration files that describe the target runtime environment.",
	"type": "array",
	"uniqueItems": true,
	"items": {
		"type": "string",
		"anyOf": [
			{ ... }
		]
	},
	"markdownDescription": "Specify a set of bundled library declaration files that describe the target runtime environment."
}
```

**target**
- 빌드의 결과물을 어떤 버전으로 할 것인지 설정한다.
- 지정은 안하면 es3이다.

**lib**
- 기본 type definition 라이브러리를 어떤 것을 사용할 것인지 결정한다.
- lib를 지정하지 않을 때, (target에 따라 자동으로 설정됨)
    - target이 ‘es3’이고, default로 lib.d.ts 를 사용한다.
    - target이 ‘es5’이면, default로 dom, es5, scripthost 를 사용한다.
    - target이 ‘es6’이면, default로 dom, es6, dom.iterable, scripthost 를 사용한다.
- lib를 지정하면 그 lib 배열로만 라이브러리를 사용한다.
    - 빈 [ ] (배열) ⇒ error! ‘no definition found ~~’

## __compileOptions - outDirm outFile, rootDir__
---

```json
"outFile": {
	"description": "Specify a file that bundles all outputs into one JavaScript file. If `declaration` is true, also designates a file that bundles all .d.ts output.",
	"type": "string",
	"markdownDescription": "Specify a file that bundles all outputs into one JavaScript file. If `declaration` is true, also designates a file that bundles all .d.ts output."
}

"outDir": {
	"description": "Specify an output folder for all emitted files.",
	"type": "string",
	"markdownDescription": "Specify an output folder for all emitted files."
}

"rootDirs": {
	"description": "Allow multiple folders to be treated as one when resolving modules.",
	"type": "array",
	"uniqueItems": true,
	"items": {
		"type": "string"
	},
	"markdownDescription": "Allow multiple folders to be treated as one when resolving modules."
}
```

**outFile**

단일 파일로 합쳐서 출력한다.

**outDir**

해당 디렉토리로 결과 구조를 보낸다.

**rootDir**

입력 파일의 루트 디렉토리 설정으로, --outDir로 결과 디렉토리 구조를 조작할 때 사용됩니다.

- rootDir 설정했을 때
    
  파일 구조 설명 
  - src/test.ts
  - src/hello.ts
  
  ```json
  "rootDir": "./src"
  "outDir": "./dist"
  ```
  
  컴파일 시(npx tsc), dist 폴더가 생성되면 해당 폴더 안에 test.js와 hello.js 파일이 생성된다.
  
- rootDir 설정하지 않을 때
    
    파일 구조 설명
  
  - src/test.ts
  - ./hello.ts
  
  ```json
  // "rootDir": "./src"
  "outDir": "./dist"
  ```
  
  컴파일 시, dist 폴더가 생성되면서 해당 폴더 안에 src폴더가 만들어진다.
  
  컴파일 이후, 폴더 구조 설명
  - dist/src/tset.js
  - dist/hello.js
  
  rootDir을 따로 설정하지 않았기 때문에 루트(시작점)이 해당 폴더(compilation-context, 최상위)가 된 것이다. rootDir을 설정했을 때에는 해당 설정이 루트(시작점)이 된다.