---
layout: post
categories:
  - TIL
title: "JavaScript: JS 데이터 Ep.10 (객체, 구조 분해 할당)"
tags:
  - TIL
  - JS
---

## __객체__
---

### __메소드__

Object ⇒ 전역 객체
- Object.assign(대상객체, 출처객체)  

  출처객체의 데이터가 대상객체에 추가가 되면서 대상객체의 데이터 내용은 기존 대상객체가 가진 데이터 + 출처객체 데이터로 새롭게 변경된다.
  
  assign 메소드는 만들어둔 userAge, userEmail에 직접 사용할 수 없다.  
  assign은 Object라는 자바스크립트 전역객체의 프로토타입으로 만들어진 메소드가 아니기 때문에 일반적인 실제 객체 데이터(userAge 등)에 직접 사용을 할 수가 없다.  
  그래서 Object라는 전역객체의 직접적으로 사용하는 메소드이며 이것을 __정적 메소드(static)__ 라고 부른다.
  
  ```js
  const userAge = {
    // key: value
    name: 'Soha',
    age: 45
  }
  const userEmail = {
    name: 'Soha',
    email: 'soha@gmail.com'
  }
  
  const target = Object.assign(userAge, userEmail)
  console.log(target)
  // name: 'Soha',
  // age: 45,
  // email: 'soha@gmail.com'
  console.log(userAge)
  // 위 코드 결과와 동일
  console.log(target === userAge)
  // true
  ```
  생긴것이 똑같아서 일치연산자를 사용했을 때 같다고 나오는 것이 아니다.
  
  - 동일한 생김새지만 일치연산자는 false
    ```js
    const a = { k: 123 }
    const b = { k: 123 }
    console.log(a === b)
    // false
    ```
    해당 코드는 생김새가 완전히 동일하지만 일치연산자의 결과는 false이다. 이것은 생김새만 같을 뿐 동일한 것이 아니기 때문이다.   
    즉, 나와 내 친구가 같은 기종의 핸드폰을 들고 있지만 소유주가 다르기에 다른 곳에 위치해 있는 것 이랄까?   
    a의 데이터는 메모리 1번에, b의 데이터는 메모리2번에 저장되어 있다. 동일하게 생겼지만 다른 주소를 가지고 있기에 일치연산자를 했을 시 false라는 결과가 나온다. 
    
    위의 target과 userAge는 **메모리 주소**가 동일하기 때문에 일치연산자 결과가 true로 나온다.   
    userAge의 데이터가 1번 메모리에 저장되어 있다고 했을 때, userAge는 메모리 1번의 주소를 가지고 있다. target은 userAge의 값을 받기 때문에 target 또한 메모리 1번의 주소를 가지고 있게 된다.   
    따라서, 일치연산자를 했을때 target과 userAge는 **모두 메모리 1번의 주소**를 가리키고 있기에 true값이 나오게 된다.
    
    - 참조형 데이터  
    메모리에 있는 특정 주소를 참조만 해서 사용하는 것.   
    객체, 배열, 함수가 이에 해당.

  - 새로운 객체를 만드는 방법

    ```js
    const target = Object.assign({}, userAge, userEmail)
    console.log(target === userAge)
    // false
    ```
    대상객체는 객체 리터럴( {} )이 되면서 userAge와 userEmail은 출처객체가 된다. 빈 객체 데이터가 userAge와 userEmail의 데이터를 가지게 되면서 빈 객체 데이터가 target이라는 변수에 반환이 된다.  
    이렇게 하면 userAge의 데이터는 변하지 않게 되면서 userAge와 userEmail을 합칠 수 있게 된다.
    ```jsx
    const target = Object.assign({}, userAge)
    console.log(target)
    // name: 'Soha',
    // age: 45
    console.log(userAge)
    // name: 'Soha',
    // age: 45
    console.log(target === userAge)
    // false
    ```
    
    같은 데이터 값을 가지고 있지만 가지고 있는 주소가 다르기 때문에 false라고 나온다! 즉, 서로 다른 객체 라는 것
    
- Object.keys
    
  객체 데이터의 속성 이름들을 배열로 만들어서 반환한다. 
    
  ```js
  const user = {
    name: 'Soha',
    age: 45,
    email: 'soha@gmail.com'
  }
  
  const keys = Object.keys(user)
  console.log(keys)
  // ['name', 'age', 'email']
  ```
  
  - 객체 데이터에서 대괄호를 사용하는 인덱싱 방법  
    원하는 속성의 값을 가져오기
    ```js
    console.log(user['email'])
    // soha@gmail.com
    ```
      
  - 객체 데이터의 값들만 추출하기  
    인덱싱 방법을 통해 동적으로 객체 데이터 내에 있는 내용들을 가져와서 활용하는 방법
    
    ```js
    const values = keys.map(key => user[key])
    console.log(values)
    // ["Soha", 45, "soha@gmail.com"]
    ```
    keys는 user라는 객체의 속성들을 배열 형태로 가지고 있는 배열데이터이다.
    
    배열데이터에는 직접적으로 map이라는 메소드를 사용할 수 있다.   
    배열데이터가 가지고 있는 아이템의 갯수만큼 콜백함수를 반복적으로 실행한다. 콜백함수가 실행될때마다 아이템(name)이 key라는 매개변수에 들어가고 user[name]이 되면서 해당 속성의 값(’Soha’)이 반환된다.   
    + *화살표 함수에서 중괄호가 작성되어져 있지 않으면 하나의 실행문이 콜백함수에서 밖으로 반환될 수 있는 구조이다.*   
    
    map이라는 메소드는 콜백에서 반환된 특정한 데이터를 배열로 만들어서 반환해주는 기능을 가지고 있다. 따라서 user라는 객체에서 key부분의 값들을 추출해서 배열로 만들어 반환하고 있다.values라는 변수에 반환 내용을 담고 있다.