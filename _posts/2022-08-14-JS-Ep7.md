---
layout: post
categories:
  - TIL
title: "JavaScript: JS 클래스 공부 Ep.7 (생성자 함수, this, ES6 Classes, 상속(확장))"
tags:
  - TIL
  - JS
---
## __생성자 함수 (prototype)__
---

### __객체데이터의 구조__
- firstName, lastName: 속성
- getFullName: 메소드, 속성에 함수가 부여되어져 있다면 더이상 속성이 아닌 메소드라고 부른다!
- 멤버 (Member): 속성과 메소드를 합쳐서 부르는 말이다.
- this == soha  
  this는 해당 객체를 지칭한다.

  ```js
  const soha = {
    firstName: 'Soha',
    lastName: 'Choe',
    getFullName: function () {
      return `${this.firstName} ${this.lastName}`
    }
  }

  console.log(soha.getFullName())
  // Soha Choe

  const amy = {
    firstName: 'Amy',
    lastName: 'Clarke',
    getFullName: function () {
      return `${this.firstName} ${this.lastName}`
    }
  }

  console.log(amy.getFullName())
  // Amy Clarke
  ```

### __동일한 로직 반복해서 찍어낼 때의 단점__
중괄호를 사용하는 객체데이터를 하나씩 만들때마다 메모리에 저장이 된다. 그렇게 저장된 객체데이터 내부에 하나의 함수 또한 데이터이다. 로직이 동일함에도 불구하고 우리가 만들어내는 객체데이터의 갯수만큼 함수도 메모리에 계속 할당된다.   
즉, 메모리 낭비가 된다는 말이다.  
이럴때 사용할 수 있는 것이 자바스크립트의 **클래스**이다.


### __클래스 이용하기__
자바스크립트의 클래스는 프로그래밍 언어에서 사용하는 클래스와는 조금 다르다.

- **생성자 함수**
  생성하는 함수로, 하나의 객체 데이터가 생성된다.
    
  ```js
  function user(first, last) {
    this.firstName = first
    this.lastName = last
  }
  
  const soha = new user('Soha', 'Choe')
  
  console.log(soha)
  // user {firstName: "Soha", lastName: "Choe"}
  ```
    - soha라는 변수에 user라는 함수를 실행해서 첫번째 변수 ‘Soha’, first에, 두번째 인수 ‘Choe’를  last에 인수로 전달한다.
    - new라는 키워드를 통해서 user 함수를 실행하게 되었다. 이때 실행한 함수(user)를 **생성자 함수**라고 부른다.

- **리터럴**  
  특정한 과정을 거치지 않고 손쉽게 해당하는 데이터를 생성하는 것이다.  
  soha 라는 변수에 할당 연산자를 통해서 중괄호를 열고 닫는 행위를 위의 코드(`function user …`)처럼 복잡하게 처리를 해야 한다. 하지만 중괄호라는 특정 기호를 통해 손쉽게 한번에 만들어 낸다.  
  특정한 기호를 가지고 데이터를 만들어 내는 것을 **리터럴 방식**이라고 한다.  
  ex) 문자 데이터를 “”(따옴표)만을 가지고 만들어 내는 것, {} 사용한 객체 데이터, [] 사용한 배열 데이터 등등
    
  ```js
  const soha = {}
  ```
    
- **인스턴스**
  ```js
  function user(first, last) {
    this.firstName = first
    this.lastName = last
  }
  
  const soha = new user('Soha', 'Choe')
  const amy = new user('Amy', 'Clarke')
  const neo = new user('Neo', 'Smith')
  
  console.log(soha)
  console.log(amy)
  console.log(neo)
  // user {firstName: "Soha", lastName: "Choe"}
  // ...
  ```
  - this 라는 것은 생성자 함수(user)를 통해서 그것이 할당되어져 있는 앞의 객체 부분(soha …)의 그 내용을 지칭하는 것이다.
  - new라는 키워드를 통해서 생성자 함수로 실행한 결과(’Soha’, ‘Choe’)를 반환해서 할당된 변수(soha)를 생성자 함수의 **인스턴스**라고 부른다.  
  soha, amy, neo 모두 인스턴스들이다.

- **prototype**
  ```js
  function User(first, last) {
    this.firstName = first
    this.lastName = last
  }
  User.prototype.getFullName = function () {
    return `${this.firstName} ${this.lastName}`
  }
  
  const soha = new User('Soha', 'Choe')
  const amy = new User('Amy', 'Clarke')
  const neo = new User('Neo', 'Smith')
  
  console.log(soha.getFullName())
  console.log(amy)
  console.log(neo)
  // Soha Choe
  // user {firstName: "Soha", lastName: "Choe"}
    // firstName: "Amy"
    // lastName: "Clarke"
    // __proto__: Object
      // getFullName: f ()
      // ...
  // ...
  ```
    - 기존 방식은 user라는 생성자 함수가 실행될때마다 다른 내용(’Soha’, ‘Neo’ 등)이 들어올 수 있기 때문에 통일해서 관리하기는 조금 어렵다.
    - getFullName은 로직(``${this.firstName} ${this.lastName}``)이 동일하기 때문에 통일화하여 메모리를 효율적으로 관리할 수 있다.
    - user라는 함수에 숨어져있는 prototype 속성에 getFullName을 할당해주면 몇개의 객체를 만들던지 간에 해당 함수는 메모리에 단 한번만 만들어진다.
    - console.log를 이용해 getFullName를 사용할때마다 함수가 만들어지는 것이 아닌 만들어진 함수를 **참조**하여 출력한다.

### **자바스크립트의 클래스**  
prototype을 사용해서 new라는 키워드와 함께 생성자 함수로 인스턴스를 만들어 내는 개념들을 **자바스크립트의 클래스**라고 부른다.

### **파스칼 케이스 == 생성자 함수**  
함수 이름을 파스칼 케이스로 작성한다. 이 말은 즉, 함수가 new라는 키워드와 함께 생성자로 사용되는 것이라는 걸 알 수 있다.